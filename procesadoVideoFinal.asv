%% Leer un archivo de video, modificar, escribir en otro
videoHandleIn = VideoReader('ejemplo.mp4');        % de donde leeremos
videoHandleOut = VideoWriter('salida.avi');   % a donde escribiremos
videoHandleOut.Quality=95;
videoHandleOut.FrameRate = videoHandleIn.FrameRate; % heredamos el frame rate

open(videoHandleOut); % creamos realmente el fichero de salida

%%
frameBefore = readFrame(videoHandleIn);
[BW, xind, yind] = roipoly(frameBefore); % se pide al usuario que dibuje un poligono alrededor de la zona de interés
R = round(sqrt((max(xind)-min(xind))/2 + (max(yind)-min(yind))/2)); % calculamos automaticamente una gaussiana adecuada
D = 2*R+1; % lo doblamos y nos aseguramos de que sea impar
g = fspecial('gaussian', D, R/3);
BWfiltered = imfilter(double(BW), g);
frameBeforeROI = im2uint8(im2double(frameBefore).*BWfiltered);

roi = images.roi.Polygon;  % creamos el objeto ROI que luego necesitaremos para actualizar máscara y posición de la ROI
roi.Position = [xind, yind];

%%
% Llamar a Harris limitándolo a que analice la imagen en la ROI, esto es, frameBeforeROI
pointsBefore = detectHarrisFeatures(frameBeforeROI, ROI=roi);
% extraer las características
[featuresBefore,validPointsBefore] = extractFeatures(frameBeforeROI, pointsBefore);


%%
while hasFrame(videoHandleIn)  % mientras hayan frames que procesar
   frameNext = readFrame(videoHandleIn); % sacamos el frame actual como imagen
   frameNextROI = im2uint8(im2double(frameNext).*BWfiltered);
   pointsNext = detectHarrisFeatures(frameNextROI, ROI=roi);
   [featuresNext,validPointsNext] = extractFeatures(frameNextROI, pointsNext);
   indexPairs = matchFeatures(featuresBefore, featuresNext);
   matchedPointsB = % qué puntos de valid points before fueron emparejados
   matchedPointsN = % qué puntos de valid points next fueron emparejados
   if matchedPointsN.Count < ¿cuanto? % si no tenemos suficientes para montar el modelo abortamos
       break;
   end

   showMatchedFeatures(frameBeforeROI,frameNextROI, matchedPointsB, matchedPointsN);
   imageCapture = getframe(gcf);
   legend('frame anterior','frame siguiente'); pause(1/videoHandleIn.FrameRate);
   
   tform = % help estimateGeometricTransform
   [xind,yind] = % help transformPoints ¿forward o inverse?

   roi.Position = [xind, yind];                    % actualizamos valores para 
   BW = roi.createMask(rgb2gray(frameActual));     % comenzar un nuevo ciclo
   BWfiltered = imfilter(double(BW), g);           % donde el frame actual pasar a 
   frameBeforeROI = im2uint8(im2double(frameNext).*BWfiltered); % ser el frame anterior
   pointsBefore = pointsNext;
   featuresBefore = featuresNext;
   validPointsBefore = validPointsNext;
   writeVideo(videoHandleOut,imageCapture.cdata); % lo escribimos
end

close(videoHandleOut);  % cerramos el video que estamos creando